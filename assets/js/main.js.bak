/* Adaryus Frontend Controller */
const Adaryus = {
    // ========================================
    // State Management
    // ========================================
    page: 'home',
    workflows: {},
    projects: [],
    downloads: [],
    promptPlaybooks: [],
    insights: [],
    charts: [],
    aiDigest: [],
    modelReleasesFeed: [],
    announcementFeed: [],
    newsCorpus: [],
    podcasts: [],
    trendTopics: [],
    
    // Performance optimization: Cache for API responses
    _apiCache: new Map(),
    _cacheExpiry: new Map(),
    CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
    
    // Performance optimization: DOM element cache
    _domCache: {},

    // ========================================
    // Core Initialization
    // ========================================
    init() {
        this.page = document.body.dataset.page || 'home';
        this.defineDataModels();
        this.cacheGlobalElements();
        this.bindNav();
        this.initScrollWatcher();
        this.initParticles();
        this.animateCounters();
        this.initChatbot();
        this.initBlueprintModal();
        this.routePageInit();
    },

    defineDataModels() {
        this.workflows = {
            'content-engine': {
                label: 'Autonomous Content Engine',
                summary: 'Research, draft, and fact-check long-form content with research validation and human approvals.',
                nodes: [
                    { id: 'signals', label: 'Signals & Briefs', x: 70, y: 60, type: 'input' },
                    { id: 'research', label: 'Research Agent', x: 200, y: 150, type: 'agent' },
                    { id: 'draft', label: 'Drafting Agent', x: 340, y: 160, type: 'agent' },
                    { id: 'editor', label: 'Editing Agent', x: 470, y: 90, type: 'agent' },
                    { id: 'qa', label: 'QA Harness', x: 270, y: 300, type: 'tool' },
                    { id: 'publish', label: 'Publish & Metrics', x: 440, y: 310, type: 'output' }
                ],
                links: [
                    ['signals', 'research'],
                    ['research', 'draft'],
                    ['draft', 'editor'],
                    ['editor', 'publish'],
                    ['draft', 'qa'],
                    ['qa', 'publish']
                ],
                timeline: [
                    { title: 'Brief ingestion', description: 'NLP normalisation, KPI tagging, and audience persona mapping.' },
                    { title: 'Research agent swarm', description: 'SERP, competitor intel, and citation harvesting with deduplication.' },
                    { title: 'Autonomous drafting', description: 'Model selection and prompt routing tuned per content pillar.' },
                    { title: 'QA & publish', description: 'Hallucination sweep, human sign-off, CMS deploy, and metric logging.' }
                ],
                json: {
                    name: 'adaryus-content-engine',
                    version: '1.2.3',
                    triggers: ['schedule', 'editor-request'],
                    agents: ['researcher', 'drafter', 'editor'],
                    tools: ['serpAPI', 'notionCMS', 'perplexity'],
                    guardrails: ['citation-check', 'toxicity-filter', 'style-guide'],
                    metrics: {
                        targetLatencyMs: 180000,
                        factualityScore: '>0.94',
                        humanReview: 'Required for tier-1 clients'
                    }
                }
            },
            'customer-support': {
                label: 'Support Copilot',
                summary: 'Contextual support answers with policy-aware guardrails and auto ticket routing.',
                nodes: [
                    { id: 'webhook', label: 'Inbound Ticket', x: 80, y: 100, type: 'input' },
                    { id: 'classifier', label: 'Intent Classifier', x: 210, y: 80, type: 'tool' },
                    { id: 'retrieval', label: 'RAG Retrieval', x: 210, y: 200, type: 'tool' },
                    { id: 'copilot', label: 'Support Copilot', x: 360, y: 140, type: 'agent' },
                    { id: 'escalation', label: 'Escalation Router', x: 480, y: 220, type: 'tool' },
                    { id: 'crm', label: 'CRM Update', x: 360, y: 300, type: 'output' }
                ],
                links: [
                    ['webhook', 'classifier'],
                    ['classifier', 'copilot'],
                    ['classifier', 'retrieval'],
                    ['retrieval', 'copilot'],
                    ['copilot', 'crm'],
                    ['copilot', 'escalation']
                ],
                timeline: [
                    { title: 'Signal scoring', description: 'Real-time triage using vector similarity and priority heuristics.' },
                    { title: 'Policy aware generation', description: 'Grounded responses referencing approved policy snippets.' },
                    { title: 'Routing logic', description: 'Escalate high-risk tickets with contextual snapshots.' },
                    { title: 'Closed-loop learning', description: 'Feedback ingestion calibrates tone, product updates, and macros.' }
                ],
                json: {
                    name: 'adaryus-support-copilot',
                    version: '4.0.0',
                    integrations: ['Zendesk', 'Salesforce', 'Slack'],
                    evaluation: ['toxicity', 'bias', 'latency'],
                    alerts: {
                        onCall: 'PagerDuty',
                        anomalyDetection: 'openmetrics'
                    }
                }
            },
            analytics: {
                label: 'Analytics Command Desk',
                summary: 'Interactive analytics assistant that composes SQL, validates output, and narrates KPI shifts.',
                nodes: [
                    { id: 'request', label: 'Analyst Prompt', x: 60, y: 120, type: 'input' },
                    { id: 'planner', label: 'Query Planner', x: 200, y: 120, type: 'agent' },
                    { id: 'sql', label: 'SQL Generator', x: 340, y: 90, type: 'agent' },
                    { id: 'warehouse', label: 'Warehouse Exec', x: 340, y: 220, type: 'tool' },
                    { id: 'validator', label: 'Validator', x: 480, y: 160, type: 'tool' },
                    { id: 'story', label: 'Narrative Builder', x: 340, y: 320, type: 'agent' }
                ],
                links: [
                    ['request', 'planner'],
                    ['planner', 'sql'],
                    ['sql', 'warehouse'],
                    ['warehouse', 'validator'],
                    ['validator', 'story'],
                    ['story', 'planner']
                ],
                timeline: [
                    { title: 'Prompt parsing', description: 'Intent extraction, KPI resolution, and compliance checks.' },
                    { title: 'Plan synthesis', description: 'Multi-step SQL generation with schema-aware templating.' },
                    { title: 'Result validation', description: 'Guardrails run distribution checks plus unit comparisons.' },
                    { title: 'Narrative mode', description: 'Explain KPI shifts with charts, anomaly alerts, and next steps.' }
                ],
                json: {
                    name: 'adaryus-analytics-command-desk',
                    version: '0.9.8',
                    dataSources: ['snowflake', 'bigquery'],
                    safeguards: ['row-level security', 'query sandbox'],
                    outputs: ['insight-report', 'slack-summary', 'csv-export']
                }
            }
        };

        this.projects = [
            {
                id: 'content-engine',
                title: 'AI Content Engine',
                headline: 'Tripled output while raising editorial quality for a SaaS marketing team.',
                metrics: ['12x faster drafting', '0.98 factuality score', 'Full audit log'],
                stack: ['n8n', 'OpenAI', 'Pinecone', 'Notion'],
                blueprint: this.workflows['content-engine'].json,
                summary: 'Orchestrated research, drafting, and editing agents with automated fact checking and CMS delivery.'
            },
            {
                id: 'support-copilot',
                title: 'RAG Support Copilot',
                headline: 'Deflected 63% of tickets with confidence-based routing and policy citations.',
                metrics: ['-42% handle time', '+18 NPS', 'SOC2 aligned'],
                stack: ['LangGraph', 'pgvector', 'Zendesk'],
                blueprint: this.workflows['customer-support'].json,
                summary: 'Hybrid retrieval, structured macros, and guardrails ensure safe customer responses with instant CRM updates.'
            },
            {
                id: 'analytics-desk',
                title: 'Analytics Command Desk',
                headline: 'Automated weekly growth narratives for RevOps across 7 data sources.',
                metrics: ['90% analyst time saved', 'Automated QA', 'Narrative playbooks'],
                stack: ['dbt', 'Snowflake', 'Anthropic'],
                blueprint: this.workflows.analytics.json,
                summary: 'Agentic SQL assistants pair with validator modules to produce trustworthy metrics and recommended actions.'
            }
        ];

        this.downloads = [
            {
                id: 'architecture-pack',
                name: 'Multi-agent Architecture Guide (PDF)',
                category: 'Architecture',
                format: 'PDF',
                description: 'Design playbooks for orchestrating multi-agent systems with governance and observability layers.',
                size: '2.4 MB',
                data: '# Multi-agent Architecture\n\n- Interaction topologies\n- Routing policies\n- Evaluation harness setup\n- Observability checklist\n'
            },
            {
                id: 'crm-kit',
                name: 'Predictive CRM Workflow (JSON)',
                category: 'Workflow',
                format: 'JSON',
                description: 'Ready-to-import n8n automation for revenue teams with lead scoring and lifecycle triggers.',
                size: '56 KB',
                data: JSON.stringify({
                    name: 'crm-predictive-automation',
                    version: '1.0.0',
                    triggers: ['crm.ticket.created', 'calendar.weekly'],
                    tasks: ['score_lead', 'notify_owner', 'update_dashboard']
                }, null, 2)
            },
            {
                id: 'video-pipeline',
                name: 'Video Automation Pipeline (Notebook)',
                category: 'Media',
                format: 'IPYNB',
                description: 'Notebook outlining automated script writing, asset sourcing, and rendering pipeline.',
                size: '312 KB',
                data: '{\n  "cells": [],\n  "metadata": {"name": "video-automation"},\n  "nbformat": 4,\n  "nbformat_minor": 5\n}'
            },
            {
                id: 'api-template',
                name: 'Automation API Template (Markdown)',
                category: 'Documentation',
                format: 'MD',
                description: 'API starter kit for running automation orchestration behind secure endpoints.',
                size: '14 KB',
                data: '# Automation API Template\n\n## Authentication\n- Bearer tokens\n- HMAC signatures\n'
            },
            {
                id: 'cost-optimizer',
                name: 'Cost Optimization Playbook (PDF)',
                category: 'Operations',
                format: 'PDF',
                description: 'Strategies to reduce inference costs while maintaining SLA fidelity using smart batching and caching.',
                size: '1.1 MB',
                data: '# Cost Optimisation Guide\n\n1. Monitor usage buckets\n2. Apply dynamic model routing\n3. Cache frequent prompts\n'
            },
            {
                id: 'prompt-library-pack',
                name: 'Prompt Library Master Pack (Markdown)',
                category: 'Prompt Ops',
                format: 'MD',
                description: 'Sequenced prompt recipes for sales, customer success, and operations leadership teams.',
                size: '22 KB',
                data: '# Prompt Library Master Pack\n\n## Sales Acceleration\n- Discovery call planner\n- Executive summary drafter\n- Competitive intel synthesiser\n\n## Customer Success\n- Risk signal explainer\n- Renewal reinforcement script\n- Upsell story builder\n\n## Operations\n- Incident briefing organiser\n- Weekly KPI narrator\n- Cost variance investigator\n'
            },
            {
                id: 'revenue-copilot-blueprint',
                name: 'Revenue Copilot Blueprint (PDF)',
                category: 'Revenue',
                format: 'PDF',
                description: 'Enterprise reference architecture for pipeline acceleration copilots with executive-ready reporting.',
                size: '3.2 MB',
                data: '# Revenue Copilot Blueprint\n\n1. Signal ingestion mesh\n2. Qualification heuristics\n3. Playbook routing logic\n4. Forecast narrative templates\n'
            },
            {
                id: 'support-resilience-runbook',
                name: 'Customer Service Automation Runbook (PDF)',
                category: 'Support',
                format: 'PDF',
                description: 'Policy-aware customer support automation with escalation ladders and satisfaction recovery sequences.',
                size: '2.8 MB',
                data: '# Customer Service Automation Runbook\n\n- Tiered escalation triggers\n- Guardrail prompts\n- Conversational QA checklist\n- NPS recovery strategy\n'
            },
            {
                id: 'ops-scorecard-schema',
                name: 'Operations Scorecard Schema (JSON)',
                category: 'Operations',
                format: 'JSON',
                description: 'Normalized schema for automation performance dashboards covering quality, cost, and throughput.',
                size: '18 KB',
                data: JSON.stringify({
                    version: '1.2.0',
                    metrics: [
                        { id: 'quality_score', label: 'Quality Score', target: 0.94 },
                        { id: 'latency_p95', label: 'Latency P95', target: 220 },
                        { id: 'cost_per_run', label: 'Cost Per Run', target: 0.42 },
                        { id: 'human_override', label: 'Human Override Rate', target: 0.03 }
                    ],
                    dimensions: ['business_unit', 'region', 'use_case']
                }, null, 2)
            }
        ];

        this.promptPlaybooks = [
            {
                id: 'content-suite',
                title: 'Content Engine Agents',
                category: 'Content Ops',
                steps: ['Research Agent briefing grid', 'Drafting Agent tone adaptors', 'Editing Agent QA rubric'],
                workflow: ['Collect SERP highlights', 'Assemble structural outline', 'Draft w/ targeted voice', 'Run QA & compliance checks']
            },
            {
                id: 'rag-audit',
                title: 'RAG Quality Audit',
                category: 'Knowledge Ops',
                steps: ['Vector integrity check', 'Chunk overlap sweep', 'Metric logging prompts'],
                workflow: ['Run embedding health-check', 'Compare semantic vs keyword recall', 'Generate hallucination report']
            },
            {
                id: 'automation-discovery',
                title: 'Automation Discovery Sprint',
                category: 'Strategy',
                steps: ['Process mapping prompt', 'ROI scoring rubric', 'Risk heatmap generator'],
                workflow: ['Interview stakeholders', 'Sequence automation roadmap', 'Quantify value & risk', 'Stakeholder alignment']
            }
        ];

        this.insights = [
            {
                id: 'hallucination-sweeps',
                title: 'Hallucination sweeps that scale',
                tags: ['EvalOps', 'Safety'],
                excerpt: 'Combine retrieval proofs, counterfactual prompts, and policy checklists to keep outputs trustworthy.',
                body: 'We layer retrieval proofs, deterministic fallbacks, and rebuttal prompts to interrogate generations. Automated sweeps cover high-risk intents before human review.',
                code: 'def sweep_outputs(samples):\n    for case in samples:\n        result = run_agent(case)\n        assert result.has_sources()\n        assert result.confidence >= 0.85\n        yield log_case(result)'
            },
            {
                id: 'vector-mesh',
                title: 'Building a resilient vector mesh',
                tags: ['RAG', 'Infrastructure'],
                excerpt: 'Hybrid search, freshness scoring, and embedding diffing keep retrieval precise and fast.',
                body: 'The mesh combines semantic, keyword, and metadata filters. Freshness scores and diff alerts catch drift while pgvector replicas keep latency low.',
                code: "SELECT id, similarity FROM documents ORDER BY embedding <=> $1 LIMIT 8;"
            },
            {
                id: 'policy-layer',
                title: 'Policy-aware agent routing',
                tags: ['Governance'],
                excerpt: 'Codify policy states so each agent run respects region, audience, and compliance profiles.',
                body: 'Policy selectors evaluate intent and jurisdiction before delegating to execution agents. Violations trigger human escalation with context payloads.',
                code: 'if policy.requires_override(intent):\n    return escalate_with_context(intent, artifacts)'
            }
        ];

        this.podcasts = [
            {
                title: 'Last Week in AI',
                hosts: 'Andrey Kurenkov & Jeremie Harris',
                description: 'Weekly recap blending research breakthroughs, policy shifts, and industry launches.',
                link: 'https://podcasts.apple.com/us/podcast/last-week-in-ai/id1502782720',
                cadence: 'Weekly ‚Ä¢ ~60 min'
            },
            {
                title: 'This Day in AI Podcast',
                hosts: 'Michael & Chris Sharkey',
                description: 'Daily-style news hits on model releases, AI infrastructure, and emerging tooling.',
                link: 'https://podcasts.apple.com/us/podcast/this-day-in-ai-podcast/id1671087656',
                cadence: 'Multiple times weekly ‚Ä¢ ~35 min'
            },
            {
                title: 'AI for Humans',
                hosts: 'Kevin Pereira & Gavin Purcell',
                description: 'Accessible tour through practical AI apps, with humor and hands-on demos.',
                link: 'https://podcasts.apple.com/us/podcast/ai-for-humans-making-artificial-intelligence-fun-practical/id1682409647',
                cadence: 'Weekly ‚Ä¢ ~55 min'
            },
            {
                title: 'The Artificial Intelligence Show',
                hosts: 'Paul Roetzer & Mike Kaput',
                description: 'Marketing and business leaders decode AI strategy, governance, and adoption.',
                link: 'https://podcasts.apple.com/us/podcast/the-artificial-intelligence-show/id1548733275',
                cadence: 'Weekly ‚Ä¢ ~45 min'
            },
            {
                title: 'Everyday AI Podcast',
                hosts: 'Jordan Wilson',
                description: 'Daily practical walkthroughs on using AI workflows inside careers and companies.',
                link: 'https://podcasts.apple.com/us/podcast/everyday-ai-podcast-an-ai-and-chatgpt-podcast/id1683401861',
                cadence: 'Daily ‚Ä¢ ~20 min'
            },
            {
                title: 'Latent Space: The AI Engineer Podcast',
                hosts: 'Alessio Fanelli & swyx',
                description: 'Deep dives with builders shaping the AI stack, from infra to agent frameworks.',
                link: 'https://podcasts.apple.com/us/podcast/latent-space-the-ai-engineer-podcast/id1674008350',
                cadence: 'Weekly ‚Ä¢ ~70 min'
            },
            {
                title: 'AI Today Podcast',
                hosts: 'Kathleen Walch & Ron Schmelzer',
                description: 'Enterprise leaders explore AI governance, ROI measurement, and real-world deployments.',
                link: 'https://podcasts.apple.com/us/podcast/ai-today-podcast/id1279927057',
                cadence: 'Weekly ‚Ä¢ ~40 min'
            },
            {
                title: 'The Next Wave: AI and the Future of Technology',
                hosts: 'Matt Wolfe & Nathan Lands',
                description: 'Forward-looking takes on AI acceleration, creative use cases, and platform roadmaps.',
                link: 'https://podcasts.apple.com/us/podcast/the-next-wave-ai-and-the-future-of-technology/id1738550343',
                cadence: 'Weekly ‚Ä¢ ~50 min'
            }
        ];
    },

    // ========================================
    // DOM & Event Handling
    // ========================================
    cacheGlobalElements() {
        // Cache commonly accessed elements
        const elements = {
            navbar: 'navbar',
            mobileToggle: 'mobile-toggle',
            mobileMenu: 'mobile-menu',
            blueprintModal: 'blueprint-modal',
            modalTitle: 'modal-title',
            modalSummary: 'modal-summary',
            modalCode: 'modal-code',
            canvas: 'particle-canvas'
        };
        
        // Batch DOM queries for better performance
        Object.entries(elements).forEach(([key, id]) => {
            this[key] = document.getElementById(id);
        });
    },
    
    // Performance helper: Get cached DOM element
    getElement(id) {
        if (!this._domCache[id]) {
            this._domCache[id] = document.getElementById(id);
        }
        return this._domCache[id];
    },

    bindNav() {
        if (this.mobileToggle && this.mobileMenu) {
            this.mobileToggle.addEventListener('click', () => {
                this.mobileMenu.classList.toggle('active');
            });
        }
    },

    initScrollWatcher() {
        if (!this.navbar) return;
        const toggleClass = () => {
            if (window.scrollY > 32) {
                this.navbar.classList.add('scrolled');
            } else {
                this.navbar.classList.remove('scrolled');
            }
        };
        toggleClass();
        window.addEventListener('scroll', toggleClass, { passive: true });
    },

    initParticles() {
        if (!this.canvas) return;
        const context = this.canvas.getContext('2d');
        const particleCount = 42;
        const particles = Array.from({ length: particleCount }, () => this.createParticle());

        const resize = () => {
            this.canvas.width = window.innerWidth * window.devicePixelRatio;
            this.canvas.height = window.innerHeight * window.devicePixelRatio;
        };
        resize();
        window.addEventListener('resize', resize);

        const draw = () => {
            context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.x < 0 || p.x > this.canvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > this.canvas.height) p.vy *= -1;
                context.beginPath();
                context.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                context.fillStyle = p.color;
                context.fill();
            });
            requestAnimationFrame(draw);
        };
        draw();
    },

    createParticle() {
        const palette = ['rgba(56, 189, 248, 0.3)', 'rgba(168, 85, 247, 0.25)', 'rgba(250, 204, 21, 0.25)'];
        return {
            x: Math.random() * window.innerWidth * window.devicePixelRatio,
            y: Math.random() * window.innerHeight * window.devicePixelRatio,
            vx: (Math.random() - 0.5) * 0.6,
            vy: (Math.random() - 0.5) * 0.6,
            r: Math.random() * 2.2 + 1.2,
            color: palette[Math.floor(Math.random() * palette.length)]
        };
    },

    animateCounters() {
        const counters = document.querySelectorAll('[data-counter]');
        if (!counters.length) return;
        
        const animate = (counter) => {
            const target = Number(counter.dataset.counter);
            const suffix = counter.textContent.replace(/[0-9.]/g, '').trim();
            const duration = 1400;
            const decimals = target < 5 ? 1 : 0;
            
            const step = timestamp => {
                if (!counter.startTime) counter.startTime = timestamp;
                const progress = Math.min((timestamp - counter.startTime) / duration, 1);
                const value = (target * progress).toFixed(decimals);
                counter.textContent = suffix ? `${value}${suffix}` : value;
                if (progress < 1) requestAnimationFrame(step);
            };
            requestAnimationFrame(step);
        };
        
        // Use forEach instead of iteration to avoid creating unnecessary closures
        counters.forEach(animate);
    },

    initBlueprintModal() {
        if (!this.blueprintModal) return;
        const openButtons = document.querySelectorAll('[data-blueprint-trigger]');
        openButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const id = btn.dataset.blueprintTrigger;
                const workflow = this.workflows[id];
                if (!workflow) return;
                this.modalTitle.textContent = workflow.label;
                this.modalSummary.textContent = workflow.summary;
                this.modalCode.textContent = JSON.stringify(workflow.json, null, 2);
                this.blueprintModal.classList.add('active');
                this.blueprintModal.setAttribute('aria-hidden', 'false');
            });
        });
        const closeButtons = this.blueprintModal.querySelectorAll('[data-close-modal]');
        closeButtons.forEach(close => close.addEventListener('click', () => this.closeModal()));
        this.blueprintModal.addEventListener('click', e => {
            if (e.target === this.blueprintModal) {
                this.closeModal();
            }
        });
    },

    closeModal() {
        if (!this.blueprintModal) return;
        this.blueprintModal.classList.remove('active');
        this.blueprintModal.setAttribute('aria-hidden', 'true');
    },

    initChatbot() {
        const toggle = document.getElementById('chatbot-toggle');
        const panel = document.getElementById('chatbot-panel');
        const body = document.getElementById('chatbot-body');
        const input = document.getElementById('chatbot-input');
        const send = document.getElementById('chatbot-send');
        if (!toggle || !panel || !body || !input || !send) return;

        const docs = [
            { id: 'retrieval', content: 'We adopt multi-store retrieval with hybrid search, citation logging, and continuous evaluation harnesses.', source: 'Retrieval Playbook' },
            { id: 'guardrails', content: 'Guardrails combine policy prompts, deterministic fallbacks, and audit logs to prevent hallucinations.', source: 'Guardrail Stack' },
            { id: 'observability', content: 'Production automations stream metrics into Grafana with anomaly detection and PagerDuty hooks.', source: 'Ops Console' },
            { id: 'evaluation', content: 'Automated evals benchmark accuracy, sentiment, and policy compliance across weekly cohorts.', source: 'Evaluation Suite' }
        ];

        const addMessage = (text, role, sources = []) => {
            const el = document.createElement('div');
            el.className = `message ${role}`;
            el.innerHTML = `<p>${text}</p>`;
            if (sources.length) {
                const list = sources.map(src => `<span>${src}</span>`).join(', ');
                const meta = document.createElement('div');
                meta.className = 'sources';
                meta.textContent = `Sources: ${list}`;
                el.appendChild(meta);
            }
            body.appendChild(el);
            body.scrollTop = body.scrollHeight;
        };

        const respond = query => {
            const terms = query.toLowerCase().split(/\W+/).filter(Boolean);
            const ranked = docs.map(doc => ({
                doc,
                score: terms.reduce((acc, term) => acc + (doc.content.includes(term) ? 1 : 0), 0)
            })).sort((a, b) => b.score - a.score);
            const top = ranked.slice(0, 2).map(item => item.doc);
            const answer = top.length
                ? `We operate a layered approach combining ${top.map(item => item.content.toLowerCase()).join(' Also, ')}`
                : 'We scope each automation with safeguards, evaluations, and human oversight to keep outcomes reliable.';
            addMessage(answer, 'ai', top.map(item => item.source));
        };

        toggle.addEventListener('click', () => {
            const expanded = panel.classList.toggle('active');
            toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        });

        const handleSend = () => {
            const value = input.value.trim();
            if (!value) return;
            addMessage(value, 'user');
            input.value = '';
            setTimeout(() => respond(value), 350);
        };

        send.addEventListener('click', handleSend);
        input.addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSend();
            }
        });

        addMessage('Hey there, need a summary of our guardrails or blueprint catalog?', 'ai', ['Welcome']);
    },

    // ========================================
    // Page-Specific Initialization
    // ========================================
    routePageInit() {
        switch (this.page) {
            case 'news':
                this.initNews();
                break;
            case 'home':
                this.initHome();
                break;
            case 'services':
                this.initServices();
                break;
            case 'projects':
                this.initProjects();
                break;
            case 'downloads':
                this.initDownloads();
                break;
            case 'prompts':
                this.initPrompts();
                break;
            case 'insights':
                this.initInsights();
                break;
            case 'dashboard':
                this.initDashboard();
                break;
            default:
                break;
        }
    },

    initHome() {
        if (window.Typed) {
            new window.Typed('#typed-keywords', {
                strings: ['agent workflows', 'retrieval copilots', 'automation desk ops'],
                typeSpeed: 42,
                backSpeed: 22,
                loop: true
            });
        }
        this.renderWorkflowDiagram('content-engine');
        const tabs = document.getElementById('workflow-tabs');
        if (tabs) {
            tabs.querySelectorAll('[data-workflow]').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.renderWorkflowDiagram(btn.dataset.workflow);
                });
            });
        }
    },

    renderWorkflowDiagram(id) {
        const cfg = this.workflows[id];
        const svg = document.getElementById('workflow-svg');
        const detail = document.getElementById('workflow-detail');
        if (!cfg || !svg || !detail) return;
        svg.innerHTML = '';
        const ns = 'http://www.w3.org/2000/svg';
        cfg.links.forEach(([fromId, toId]) => {
            const from = cfg.nodes.find(n => n.id === fromId);
            const to = cfg.nodes.find(n => n.id === toId);
            if (!from || !to) return;
            const line = document.createElementNS(ns, 'line');
            line.setAttribute('x1', from.x);
            line.setAttribute('y1', from.y);
            line.setAttribute('x2', to.x);
            line.setAttribute('y2', to.y);
            line.setAttribute('stroke', 'rgba(56, 189, 248, 0.35)');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-linecap', 'round');
            svg.appendChild(line);
        });
        cfg.nodes.forEach(node => {
            const circle = document.createElementNS(ns, 'circle');
            circle.setAttribute('cx', node.x);
            circle.setAttribute('cy', node.y);
            circle.setAttribute('r', 22);
            circle.setAttribute('fill', this.nodeFill(node.type));
            circle.setAttribute('stroke', 'rgba(56, 189, 248, 0.45)');
            circle.setAttribute('stroke-width', '2');
            svg.appendChild(circle);

            const text = document.createElementNS(ns, 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 40);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', '#cbd5f5');
            text.setAttribute('font-size', '12');
            text.textContent = node.label;
            svg.appendChild(text);
        });

        if (window.anime) {
            window.anime({
                targets: svg.querySelectorAll('line'),
                strokeDashoffset: [anime.setDashoffset, 0],
                easing: 'easeOutQuad',
                duration: 1200,
                delay: (el, i) => i * 80
            });
        }

        detail.innerHTML = '';
        cfg.timeline.forEach(step => {
            const item = document.createElement('div');
            item.className = 'timeline-entry';
            item.innerHTML = `<h4>${step.title}</h4><p>${step.description}</p>`;
            detail.appendChild(item);
        });
    },

    nodeFill(type) {
        switch (type) {
            case 'agent':
                return 'rgba(168, 85, 247, 0.25)';
            case 'tool':
                return 'rgba(56, 189, 248, 0.25)';
            case 'input':
                return 'rgba(250, 204, 21, 0.25)';
            case 'output':
                return 'rgba(52, 211, 153, 0.25)';
            default:
                return 'rgba(148, 163, 184, 0.25)';
        }
    },

    initServices() {
        const checklist = document.querySelector('[data-service-checklist]');
        if (!checklist) return;
        const items = [
            'Discovery sprint with process mapping and automation ROI grid.',
            'Blueprint deliverables: diagrams, prompts, runbooks, handoff docs.',
            'Pilot implementation with embedded Adaryus engineers.',
            'Observability plus evaluation harness to monitor adoption.',
            'Enablement workshops so internal teams stay autonomous.'
        ];
        checklist.innerHTML = '';
        items.forEach(item => {
            const li = document.createElement('li');
            li.textContent = item;
            checklist.appendChild(li);
        });
    },

    initProjects() {
        const grid = document.getElementById('project-grid');
        const modal = document.getElementById('project-modal');
        if (!grid || !modal) return;
        const list = document.createElement('div');
        list.className = 'card-grid';
        this.projects.forEach(project => {
            const card = document.createElement('article');
            card.className = 'card';
            card.innerHTML = `
                <div class="card-content">
                    <div class="card-icon">üõ∞Ô∏è</div>
                    <h3>${project.title}</h3>
                    <p>${project.headline}</p>
                    <div class="chip-list">${project.stack.map(tech => `<span class="chip">${tech}</span>`).join('')}</div>
                    <button class="btn btn-secondary" data-project-id="${project.id}">View blueprint</button>
                </div>
            `;
            list.appendChild(card);
        });
        grid.appendChild(list);

        grid.addEventListener('click', event => {
            const button = event.target.closest('[data-project-id]');
            if (!button) return;
            const project = this.projects.find(item => item.id === button.dataset.projectId);
            if (!project) return;
            modal.querySelector('#project-modal-title').textContent = project.title;
            modal.querySelector('#project-modal-summary').textContent = project.summary;
            modal.querySelector('#project-modal-metrics').innerHTML = project.metrics.map(metric => `<li>${metric}</li>`).join('');
            modal.querySelector('#project-modal-code').textContent = JSON.stringify(project.blueprint, null, 2);
            modal.classList.add('active');
        });

        modal.addEventListener('click', event => {
            if (event.target === modal || event.target.hasAttribute('data-close-modal')) {
                modal.classList.remove('active');
            }
        });
    },

    initDownloads() {
        const list = document.getElementById('download-table-body');
        const search = document.getElementById('download-search');
        const categoryFilter = document.getElementById('download-category');
        const formatFilter = document.getElementById('download-format');
        if (!list || !search || !categoryFilter || !formatFilter) return;

        const render = () => {
            const term = search.value.toLowerCase();
            const category = categoryFilter.value;
            const format = formatFilter.value;
            list.innerHTML = '';

            const filtered = this.downloads
                .filter(item => (!term || item.name.toLowerCase().includes(term) || item.description.toLowerCase().includes(term)))
                .filter(item => (category === 'all' ? true : item.category === category))
                .filter(item => (format === 'all' ? true : item.format.toLowerCase() === format.toLowerCase()));

            if (!filtered.length) {
                const emptyRow = document.createElement('tr');
                emptyRow.className = 'download-empty';
                emptyRow.innerHTML = '<td colspan="5">No assets match these filters yet. Adjust your selection or email <a href="mailto:build@adaryus.ai">build@adaryus.ai</a>.</td>';
                list.appendChild(emptyRow);
                return;
            }

            filtered.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td data-label="Asset"><strong>${item.name}</strong><p>${item.description}</p></td>
                    <td data-label="Category">${item.category}</td>
                    <td data-label="Format">${item.format}</td>
                    <td data-label="Size">${item.size}</td>
                    <td data-label="Download"><button class="btn btn-secondary" data-download-id="${item.id}">Download</button></td>
                `;
                list.appendChild(row);
            });
        };

        const download = id => {
            const item = this.downloads.find(entry => entry.id === id);
            if (!item) return;
            const extension = item.format.toLowerCase();
            const mimeTypeMap = {
                pdf: 'application/pdf',
                json: 'application/json',
                ipynb: 'application/json',
                md: 'text/markdown'
            };
            const payload = typeof item.data === 'string' ? item.data : JSON.stringify(item.data, null, 2);
            const blob = new Blob([payload], { type: mimeTypeMap[extension] || 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${item.id}.${extension}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        };

        search.addEventListener('input', render);
        categoryFilter.addEventListener('change', render);
        formatFilter.addEventListener('change', render);
        document.addEventListener('click', event => {
            const button = event.target.closest('[data-download-id]');
            if (!button) return;
            download(button.dataset.downloadId);
        });

        render();
    },

    async initNews() {
        this.aiDigest = [];
        this.modelReleasesFeed = [];
        this.announcementFeed = [];
        this.newsCorpus = [];
        this.trendTopics = [];

        this.renderSkeleton('ai-headlines', 6);
        this.renderSkeleton('model-release-grid', 6);
        this.renderSkeleton('announcement-grid', 6);

        this.renderPodcasts();
        this.initNewsChat();

        const jobs = [
            this.loadAiDigest(),
            this.loadModelReleases(),
            this.loadAnnouncements()
        ];

        const apiKey = window.AdaryusConfig && window.AdaryusConfig.newsApiKey;
        if (apiKey) {
            jobs.push(this.loadOptionalNewsApi(apiKey));
        }

        await Promise.allSettled(jobs);
        this.updateTrendList();
    },

    // ========================================
    // Data Loading & API Integration
    // ========================================
    
    // Performance helper: Cached fetch with expiry
    async cachedFetch(url, options = {}) {
        const now = Date.now();
        const cached = this._apiCache.get(url);
        const expiry = this._cacheExpiry.get(url);
        
        if (cached && expiry && now < expiry) {
            return cached;
        }
        
        const response = await fetch(url, options);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        this._apiCache.set(url, data);
        this._cacheExpiry.set(url, now + this.CACHE_DURATION);
        
        return data;
    },
    
    async loadAiDigest() {
        const endpoint = 'https://hn.algolia.com/api/v1/search_by_date?query=artificial%20intelligence%20OR%20ai%20OR%20gpt&tags=story&hitsPerPage=12';
        try {
            const payload = await this.cachedFetch(endpoint);
            const hits = Array.isArray(payload?.hits) ? payload.hits : [];
            
            // Use map + filter in one pass for better performance
            this.aiDigest = hits.reduce((acc, hit) => {
                const title = hit.title || hit.story_title || 'Untitled update';
                const fallbackUrl = `https://news.ycombinator.com/item?id=${hit.objectID}`;
                const url = hit.url || hit.story_url || fallbackUrl;
                
                if (!url) return acc;
                
                const body = hit.story_text || hit.comment_text || '';
                const summary = body ? this.truncate(this.stripHtml(body.replace(/\s+/g, ' ')), 180) : 'Community discussion on Hacker News.';
                const entry = {
                    title,
                    summary,
                    url,
                    source: 'Hacker News',
                    date: hit.created_at
                };
                this.indexNewsItem(entry);
                acc.push(entry);
                return acc;
            }, []);
            
            if (!this.aiDigest.length) {
                this.renderEmptyState('ai-headlines', 'No community headlines yet. Check back soon.');
                return;
            }
            this.aiDigest.sort((a, b) => new Date(b.date) - new Date(a.date));
            this.renderHeadlines();
        } catch (error) {
            console.error('AI digest error', error);
            this.renderErrorState('ai-headlines', 'Unable to load community headlines right now.');
        }
    },

    async loadOptionalNewsApi(apiKey) {
        const endpoint = 'https://newsapi.org/v2/everything?q=artificial%20intelligence%20OR%20machine%20learning&language=en&pageSize=10&sortBy=publishedAt';
        try {
            const payload = await this.cachedFetch(endpoint, { headers: { 'X-Api-Key': apiKey } });
            const articles = Array.isArray(payload?.articles) ? payload.articles : [];
            
            // Pre-create a Set for O(1) lookups instead of using Array.some
            const existingUrls = new Set(this.aiDigest.map(item => item.url));
            
            articles.forEach(article => {
                if (!article?.url || existingUrls.has(article.url)) return;
                
                const entry = {
                    title: article.title || 'AI headline',
                    summary: this.truncate(article.description || article.content || '', 200),
                    url: article.url,
                    source: article.source?.name || 'NewsAPI',
                    date: article.publishedAt || new Date().toISOString()
                };
                this.aiDigest.push(entry);
                this.indexNewsItem(entry);
            });
            this.aiDigest.sort((a, b) => new Date(b.date) - new Date(a.date));
            this.renderHeadlines();
        } catch (error) {
            console.warn('NewsAPI fetch skipped', error);
        }
    },

    // ========================================
    // Content Rendering Methods
    // ========================================
    renderHeadlines() {
        const container = this.getElement('ai-headlines');
        if (!container) return;
        if (!this.aiDigest.length) {
            this.renderEmptyState('ai-headlines', 'No AI headlines found right now.');
            return;
        }
        
        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        const items = this.aiDigest.slice(0, 12);
        
        items.forEach(item => {
            const article = document.createElement('article');
            article.className = 'news-card';
            article.setAttribute('role', 'listitem');
            article.innerHTML = `
                <h3><a href="${item.url}" target="_blank" rel="noopener">${this.escapeHtml(item.title)}</a></h3>
                <p>${this.escapeHtml(item.summary)}</p>
                <div class="news-card-meta">
                    <span class="badge badge-source">${this.escapeHtml(item.source)}</span>
                    <time datetime="${item.date}">${this.formatRelativeTime(item.date)}</time>
                </div>
            `;
            fragment.appendChild(article);
        });
        
        container.innerHTML = '';
        container.appendChild(fragment);
        this.updateTrendList();
    },

    async loadModelReleases() {
        const endpoint = 'https://huggingface.co/api/models?limit=12&sort=lastModified&direction=-1';
        try {
            const payload = await this.cachedFetch(endpoint);
            const models = Array.isArray(payload) ? payload : [];
            
            // Use reduce instead of map + filter
            this.modelReleasesFeed = models.reduce((acc, model) => {
                const id = model.modelId || model.id;
                if (!id) return acc;
                
                const tags = Array.isArray(model.tags) ? model.tags.slice(0, 4) : [];
                const entry = {
                    title: id,
                    summary: model.pipeline_tag ? `Pipeline: ${model.pipeline_tag}` : (model.tags?.length ? `Tags: ${model.tags.slice(0, 3).join(', ')}` : 'New model release on Hugging Face.'),
                    url: `https://huggingface.co/${id}`,
                    source: 'Hugging Face',
                    date: model.lastModified || model.lastModifiedAt || model.last_modified || new Date().toISOString(),
                    likes: typeof model.likes === 'number' ? model.likes : 0,
                    downloads: typeof model.downloads === 'number' ? model.downloads : 0,
                    tags
                };
                this.indexNewsItem(entry);
                acc.push(entry);
                return acc;
            }, []);
            
            if (!this.modelReleasesFeed.length) {
                this.renderEmptyState('model-release-grid', 'No recent model releases detected.');
                return;
            }
            this.modelReleasesFeed.sort((a, b) => new Date(b.date) - new Date(a.date));
            this.renderModelReleases();
        } catch (error) {
            console.error('Model release error', error);
            this.renderErrorState('model-release-grid', 'Unable to sync Hugging Face releases right now.');
        }
    },

    renderModelReleases() {
        const container = this.getElement('model-release-grid');
        if (!container) return;
        if (!this.modelReleasesFeed.length) {
            this.renderEmptyState('model-release-grid', 'No recent model releases detected.');
            return;
        }
        
        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        
        this.modelReleasesFeed.forEach(item => {
            const article = document.createElement('article');
            article.className = 'news-card';
            article.setAttribute('role', 'listitem');
            
            const tagsHtml = item.tags.length 
                ? `<ul class="news-card-tags">${item.tags.map(tag => `<li>${this.escapeHtml(tag)}</li>`).join('')}</ul>` 
                : '';
            
            article.innerHTML = `
                <h3><a href="${item.url}" target="_blank" rel="noopener">${this.escapeHtml(item.title)}</a></h3>
                <p>${this.escapeHtml(item.summary)}</p>
                ${tagsHtml}
                <div class="news-card-meta">
                    <span class="badge badge-source">${this.escapeHtml(item.source)}</span>
                    <time datetime="${item.date}">${this.formatRelativeTime(item.date)}</time>
                </div>
                <div class="news-card-stats">
                    <span aria-label="Model likes">‚ù§Ô∏è ${item.likes}</span>
                    <span aria-label="Model downloads">‚¨áÔ∏è ${item.downloads}</span>
                </div>
            `;
            fragment.appendChild(article);
        });
        
        container.innerHTML = '';
        container.appendChild(fragment);
        this.updateTrendList();
    },

    async loadAnnouncements() {
        const defaults = [
            'https://openai.com/blog/rss/',
            'https://www.anthropic.com/index.xml',
            'https://huggingface.co/blog/feed?type=blog'
        ];
        const feeds = (window.AdaryusConfig && Array.isArray(window.AdaryusConfig.rssFeeds) && window.AdaryusConfig.rssFeeds.length)
            ? window.AdaryusConfig.rssFeeds
            : defaults;
        const tasks = feeds.map(url => this.fetchRssFeed(url));
        const results = await Promise.allSettled(tasks);
        if (!this.announcementFeed.length) {
            const failed = results.every(result => result.status === 'rejected');
            if (failed) {
                this.renderErrorState('announcement-grid', 'Could not reach announcement feeds. Try again soon.');
            } else {
                this.renderEmptyState('announcement-grid', 'No announcements released yet today.');
            }
            return;
        }
        this.announcementFeed.sort((a, b) => new Date(b.date) - new Date(a.date));
        this.renderAnnouncements();
    },

    async fetchRssFeed(url) {
        const label = (() => {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch (error) {
                console.warn('Unable to parse RSS host', error);
                return 'AI Source';
            }
        })();
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
        const payload = await this.cachedFetch(proxyUrl);
        const parser = new DOMParser();
        const xml = parser.parseFromString(payload.contents, 'text/xml');
        const items = Array.from(xml.querySelectorAll('item, entry')).slice(0, 8);
        items.forEach(node => {
            const title = node.querySelector('title')?.textContent?.trim() || 'Untitled announcement';
            const linkNode = node.querySelector('link');
            const linkAttr = linkNode?.getAttribute('href');
            const linkText = linkNode?.textContent?.trim();
            const link = linkAttr || linkText || url;
            const description = node.querySelector('description, summary, content')?.textContent || '';
            const pubDate = node.querySelector('pubDate, updated, published')?.textContent || new Date().toISOString();
            const entry = {
                title,
                summary: this.truncate(this.stripHtml(description), 200),
                url: link,
                source: label,
                date: pubDate
            };
            this.announcementFeed.push(entry);
            this.indexNewsItem(entry);
        });
    },

    renderAnnouncements() {
        const container = this.getElement('announcement-grid');
        if (!container) return;
        if (!this.announcementFeed.length) {
            this.renderEmptyState('announcement-grid', 'No announcements yet.');
            return;
        }
        
        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        const items = this.announcementFeed.slice(0, 12);
        
        items.forEach(item => {
            const article = document.createElement('article');
            article.className = 'news-card';
            article.setAttribute('role', 'listitem');
            article.innerHTML = `
                <h3><a href="${item.url}" target="_blank" rel="noopener">${this.escapeHtml(item.title)}</a></h3>
                <p>${this.escapeHtml(item.summary)}</p>
                <div class="news-card-meta">
                    <span class="badge badge-source">${this.escapeHtml(item.source)}</span>
                    <time datetime="${item.date}">${this.formatRelativeTime(item.date)}</time>
                </div>
            `;
            fragment.appendChild(article);
        });
        
        container.innerHTML = '';
        container.appendChild(fragment);
        this.updateTrendList();
    },

    renderPodcasts() {
        const container = document.getElementById('podcast-grid');
        if (!container) return;
        container.innerHTML = this.podcasts.map(podcast => {
            this.indexNewsItem({
                title: podcast.title,
                summary: podcast.description,
                url: podcast.link,
                source: podcast.hosts,
                date: new Date().toISOString()
            });
            return `
            <article class="news-card" role="listitem">
                <h3><a href="${podcast.link}" target="_blank" rel="noopener">${this.escapeHtml(podcast.title)}</a></h3>
                <p>${this.escapeHtml(podcast.description)}</p>
                <div class="news-card-meta">
                    <span class="badge badge-source">${this.escapeHtml(podcast.hosts)}</span>
                    <span>${this.escapeHtml(podcast.cadence)}</span>
                </div>
            </article>
        `;
        }).join('');
    },

    updateTrendList() {
        const list = document.getElementById('ai-trend-list');
        if (!list) return;
        const combined = [...this.aiDigest, ...this.announcementFeed, ...this.modelReleasesFeed]
            .filter(item => item && item.date)
            .sort((a, b) => new Date(b.date) - new Date(a.date));
        if (!combined.length) {
            list.innerHTML = '<li>Waiting for fresh signals‚Ä¶</li>';
            return;
        }
        const top = combined.slice(0, 5);
        list.innerHTML = top.map(item => `
            <li>
                <a href="${item.url}" target="_blank" rel="noopener">${this.escapeHtml(item.title)}</a>
                <span>${this.escapeHtml(item.source)} ‚Ä¢ ${this.formatRelativeTime(item.date)}</span>
            </li>
        `).join('');
    },

    initNewsChat() {
        const form = document.getElementById('ai-news-chat-form');
        const input = document.getElementById('ai-news-chat-input');
        const log = document.getElementById('ai-news-chat-log');
        if (!form || !input || !log) return;

        const webhook = window.AdaryusConfig && window.AdaryusConfig.chatWebhookUrl;

        const addMessage = (html, role) => {
            const bubble = document.createElement('div');
            bubble.className = `chat-message ${role}`;
            bubble.innerHTML = html;
            log.appendChild(bubble);
            log.scrollTop = log.scrollHeight;
        };

        const handleQuery = async query => {
            if (webhook) {
                try {
                    const response = await fetch(webhook, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query })
                    });
                    if (response.ok) {
                        const payload = await response.json();
                        if (payload && payload.answer) {
                            addMessage(`<p>${this.escapeHtml(payload.answer)}</p>`, 'ai');
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Chat webhook unavailable', error);
                }
            }
            addMessage(this.answerNewsQuery(query), 'ai');
        };

        form.addEventListener('submit', event => {
            event.preventDefault();
            const query = input.value.trim();
            if (!query) return;
            addMessage(`<p>${this.escapeHtml(query)}</p>`, 'user');
            input.value = '';
            handleQuery(query);
        });

        addMessage('<p>Ask about model launches, safety policies, or podcasts to see what‚Äôs new.</p>', 'ai');
    },

    // ========================================
    // News Search & Indexing
    // ========================================
    answerNewsQuery(query) {
        if (!this.newsCorpus.length) {
            return '<p>I‚Äôm still collecting sources. Check back in a few seconds.</p>';
        }
        const tokens = query.toLowerCase().split(/\W+/).filter(Boolean);
        const scored = this.newsCorpus.map(item => {
            const score = tokens.reduce((total, token) => total + (item.text.includes(token) ? 1 : 0), 0);
            return { item, score };
        }).filter(entry => entry.score > 0)
            .sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return new Date(b.item.date) - new Date(a.item.date);
            });
        const matches = scored.slice(0, 3).map(entry => entry.item);
        if (!matches.length) {
            return '<p>I didn‚Äôt find a direct match yet. Try keywords like <strong>Claude</strong>, <strong>Hugging Face</strong>, or <strong>eval</strong>.</p>';
        }
        const items = matches.map(match => `
            <li>
                <a href="${match.url}" target="_blank" rel="noopener">${this.escapeHtml(match.title)}</a>
                <span>${this.escapeHtml(match.source)} ‚Ä¢ ${this.formatRelativeTime(match.date)}</span>
                <p>${this.escapeHtml(match.summary)}</p>
            </li>
        `).join('');
        const remainder = Math.max(0, this.newsCorpus.length - matches.length);
        const tail = remainder ? `<p>I‚Äôm tracking ${remainder} more updates today. Narrow the query for deeper links.</p>` : '';
        return `<p>Here‚Äôs what surfaced:</p><ul class="chat-results">${items}</ul>${tail}`;
    },

    indexNewsItem(item) {
        if (!item || !item.url) return;
        if (this.newsCorpus.some(entry => entry.url === item.url)) return;
        this.newsCorpus.push({
            ...item,
            text: `${item.title} ${item.summary} ${item.source}`.toLowerCase()
        });
    },

    formatRelativeTime(value) {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value || 'Just now';
        const diff = Date.now() - date.getTime();
        const tense = diff >= 0 ? 'ago' : 'from now';
        const seconds = Math.abs(diff) / 1000;
        const intervals = [
            { label: 'year', seconds: 31536000 },
            { label: 'month', seconds: 2592000 },
            { label: 'week', seconds: 604800 },
            { label: 'day', seconds: 86400 },
            { label: 'hour', seconds: 3600 },
            { label: 'minute', seconds: 60 }
        ];
        for (const interval of intervals) {
            const count = Math.floor(seconds / interval.seconds);
            if (count >= 1) {
                return `${count} ${interval.label}${count > 1 ? 's' : ''} ${tense}`;
            }
        }
        return 'Just now';
    },

    // ========================================
    // Rendering Utilities
    // ========================================
    renderSkeleton(targetId, count = 3) {
        const container = document.getElementById(targetId);
        if (!container) return;
        container.innerHTML = Array.from({ length: count }, () => `
            <article class="news-card skeleton" role="listitem" aria-busy="true">
                <div class="skeleton-line skeleton-title"></div>
                <div class="skeleton-line"></div>
                <div class="skeleton-line short"></div>
            </article>
        `).join('');
    },

    renderEmptyState(targetId, message) {
        const container = document.getElementById(targetId);
        if (!container) return;
        container.innerHTML = `<div class="empty-state">${this.escapeHtml(message)}</div>`;
    },

    renderErrorState(targetId, message) {
        const container = document.getElementById(targetId);
        if (!container) return;
        container.innerHTML = `<div class="empty-state error">${this.escapeHtml(message)}</div>`;
    },

    // ========================================
    // String & Data Utilities
    // ========================================
    truncate(text, length = 160) {
        const value = (text || '').toString().trim();
        if (value.length <= length) return value;
        const truncated = value.slice(0, length);
        return `${truncated.replace(/\s+\S*$/, '')}‚Ä¶`;
    },

    stripHtml(html) {
        if (!html) return '';
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
    },

    escapeHtml(text) {
        return String(text ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    },

    initPrompts() {
        const container = document.getElementById('prompt-grid');
        const filter = document.getElementById('prompt-filter');
        if (!container || !filter) return;

        const render = () => {
            const category = filter.value;
            container.innerHTML = '';
            this.promptPlaybooks
                .filter(playbook => (category === 'all' ? true : playbook.category === category))
                .forEach(playbook => {
                    const card = document.createElement('article');
                    card.className = 'card';
                    card.innerHTML = `
                        <div class="card-content">
                            <div class="card-icon">üß†</div>
                            <h3>${playbook.title}</h3>
                            <p>${playbook.workflow.join(' ‚Üí ')}</p>
                            <ul>${playbook.steps.map(step => `<li>${step}</li>`).join('')}</ul>
                        </div>
                    `;
                    container.appendChild(card);
                });
        };

        filter.addEventListener('change', render);
        render();
    },

    initInsights() {
        const grid = document.getElementById('insight-grid');
        const modal = document.getElementById('insight-modal');
        if (!grid || !modal) return;
        this.insights.forEach(item => {
            const card = document.createElement('article');
            card.className = 'card';
            card.innerHTML = `
                <div class="card-content">
                    <div class="card-icon">üìà</div>
                    <h3>${item.title}</h3>
                    <p>${item.excerpt}</p>
                    <div class="chip-list">${item.tags.map(tag => `<span class="chip">${tag}</span>`).join('')}</div>
                    <button class="btn btn-secondary" data-insight-id="${item.id}">Open insight</button>
                </div>
            `;
            grid.appendChild(card);
        });

        grid.addEventListener('click', event => {
            const button = event.target.closest('[data-insight-id]');
            if (!button) return;
            const insight = this.insights.find(entry => entry.id === button.dataset.insightId);
            if (!insight) return;
            modal.querySelector('#insight-modal-title').textContent = insight.title;
            modal.querySelector('#insight-modal-body').textContent = insight.body;
            modal.querySelector('#insight-modal-code').textContent = insight.code;
            modal.classList.add('active');
        });

        modal.addEventListener('click', event => {
            if (event.target === modal || event.target.hasAttribute('data-close-modal')) {
                modal.classList.remove('active');
            }
        });
    },

    // ========================================
    // Dashboard & Charts
    // ========================================
    async initDashboard() {
        const cards = document.querySelectorAll('[data-metric]');
        cards.forEach(card => {
            const trend = card.dataset.metric === 'success-rate' ? '+2.8%' : '+0.6%';
            card.querySelector('.trend').textContent = trend;
        });

        const chartContainers = document.querySelectorAll('[data-chart]');
        if (!chartContainers.length) return;
        await this.loadScript('https://cdn.jsdelivr.net/npm/chart.js');
        chartContainers.forEach(container => {
            const ctx = container.getContext('2d');
            this.charts.push(new window.Chart(ctx, this.chartConfig(container.dataset.chart)));
        });
    },

    chartConfig(type) {
        const base = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: '#cbd5f5' } },
                tooltip: { backgroundColor: 'rgba(15,23,42,0.9)' }
            },
            scales: {
                x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.12)' } },
                y: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.12)' } }
            }
        };
        switch (type) {
            case 'pipeline-throughput':
                return {
                    type: 'line',
                    data: {
                        labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                        datasets: [
                            {
                                label: 'Runs',
                                data: [420, 510, 620, 780, 960, 1040],
                                borderColor: '#38bdf8',
                                tension: 0.35,
                                fill: true,
                                backgroundColor: 'rgba(56, 189, 248, 0.12)'
                            }
                        ]
                    },
                    options: base
                };
            case 'cost-curve':
                return {
                    type: 'bar',
                    data: {
                        labels: ['Compute', 'Storage', 'LM APIs', 'Evaluations'],
                        datasets: [{
                            label: 'Quarterly Spend (k)',
                            data: [32, 12, 26, 6],
                            backgroundColor: ['#38bdf8', '#a855f7', '#facc15', '#34d399']
                        }]
                    },
                    options: base
                };
            case 'quality-scores':
                return {
                    type: 'radar',
                    data: {
                        labels: ['Accuracy', 'Latency', 'Coverage', 'Compliance', 'Satisfaction'],
                        datasets: [{
                            label: 'Score',
                            data: [95, 88, 92, 97, 91],
                            borderColor: '#a855f7',
                            backgroundColor: 'rgba(168, 85, 247, 0.18)'
                        }]
                    },
                    options: base
                };
            default:
                return {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: base
                };
        }
    },

    loadScript(src) {
        return new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) {
                resolve();
                return;
            }
            const script = document.createElement('script');
            script.src = src;
            script.async = true;
            script.onload = resolve;
            script.onerror = reject;
            document.body.appendChild(script);
        });
    }
};

document.addEventListener('DOMContentLoaded', () => Adaryus.init());
